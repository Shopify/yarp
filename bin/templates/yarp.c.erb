/******************************************************************************/
/* BEGIN TEMPLATE                                                             */
/******************************************************************************/

<%- nodes.each do |node| -%>
// Allocate a new <%= node.name %> node.
static yp_node_t *
<%- params = node.params.map(&:param).compact.join(", ") -%>
yp_node_alloc_<%= node.human %>(yp_parser_t *parser<%= params.empty? ? "" : ", #{params}" %>) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) {
    .type = <%= node.type %>,
    .location = <%= node.location %>,
    .as.<%= node.human %> = {
      <%- node.params.each do |param| -%>
      .<%= param.name %> = <%= param.assign %>,
      <%- end -%>
    },
  };
  return node;
}

<%- end -%>
// Deallocate the space for a yp_node_t. Similarly to yp_node_alloc, we're not
// using the parser argument, but it's there to allow for the future possibility
// of pre-allocating larger memory pools.
void
yp_node_dealloc(yp_parser_t *parser, yp_node_t *node) {
  switch (node->type) {
    <%- nodes.each do |node| -%>
    case <%= node.type %>:
      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when StringParam -%>
      <%- when NodeParam -%>
      yp_node_dealloc(parser, node->as.<%= node.human %>.<%= param.name %>);
      <%- when OptionalNodeParam -%>
      if (node->as.<%= node.human %>.<%= param.name %> != NULL) {
        yp_node_dealloc(parser, node->as.<%= node.human %>.<%= param.name %>);
      }
      <%- when NodeListParam -%>
      yp_node_list_dealloc(parser, node->as.<%= node.human %>.<%= param.name %>);
      <%- else -%>
      <%- raise -%>
      <%- end -%>
      <%- end -%>
      free(node);
      break;
    <%- end -%>
  }
}

/******************************************************************************/
/* END TEMPLATE                                                               */
/******************************************************************************/
