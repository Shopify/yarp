#!/usr/bin/env ruby

require "erb"
require "yaml"

# This represents a parameter to a node that is itself a node. We pass them as
# references and store them as references.
class NodeParam < Struct.new(:name)
  def decl = "struct yp_node *#{name}"
  def param = "yp_node_t *#{name}"
  def assign = name
  def rbs_class = "Node"
  def child_nodes = name

  def start_location(params) = "#{name}->location.start"
  def end_location(params) = "#{name}->location.end"
  def location(params) = "#{name}->location"
end

# This represents a parameter to a node that is itself a node and can be
# optionally null. We pass them as references and store them as references.
class OptionalNodeParam < Struct.new(:name, :fallback)
  def decl = "struct yp_node *#{name}"
  def param = "yp_node_t *#{name}"
  def assign = name
  def rbs_class = "Node?"
  def child_nodes = name

  def fallback_param(params) = params.find { |param| param.name == fallback }
  def start_location(params) = "(#{name} == NULL ? #{fallback_param(params).start_location(params)} : #{name}->location.start)"
  def end_location(params) = "(#{name} == NULL ? #{fallback_param(params).end_location(params)} : #{name}->location.end)"
  def location(params) = "(#{name} == NULL ? #{fallback_param(params).location(params)} : #{name}->location)"
end

# This represents a parameter to a node that is a list of nodes. We pass them as
# references and store them as references.
class NodeListParam < Struct.new(:name)
  def decl = "struct yp_node_list *#{name}"
  def param = nil
  def assign = "yp_node_list_alloc(parser)"
  def rbs_class = "Array[Node]"
  def child_nodes = "*#{name}"

  def start_location(params) = "0"
  def end_location(params) = "0"
  def location(params) = "{ .start = #{start_location(params)}, .end = #{end_location(params)} }"
end

# This represents a parameter to a node that is a token. We pass them as
# references and store by converting to a string.
class StringParam < Struct.new(:name)
  def decl = "yp_string_t #{name}"
  def param = "yp_token_t *#{name}"
  def assign = "token_to_string(*#{name})"
  def rbs_class = "String"
  def child_nodes = nil

  def start_location(params) = "#{name}->start - parser->start"
  def end_location(params) = "#{name}->end - parser->start"
  def location(params) = "{ .start = #{start_location(params)}, .end = #{end_location(params)} }"
end

# This class represents a node in the tree, configured by the NODE_TYPES file in
# YAML format. It contains information about the name of the node, the various
# child nodes it contains, and how to obtain the location of the node in the
# source.
class NodeType
  attr_reader :name, :type, :human, :params, :location

  def initialize(config)
    @name = config.fetch("name")

    type = @name.gsub(/(.)([A-Z])/, "\\1_\\2")
    @type = "YP_NODE_#{type.upcase}"
    @human = type.downcase

    @params =
      config.fetch("child_nodes").map do |param|
        type, name = param.split(" ")

        case type
        when "node"
          NodeParam.new(name)
        when /\Anode\?(.+)/
          OptionalNodeParam.new(name, $1)
        when "node[]"
          NodeListParam.new(name)
        when "string"
          StringParam.new(name)
        else
          raise "Unknown field type #{type.inspect}"
        end
      end

    @location =
      config.fetch("location").then do |location|
        if location.include?("->")
          from, to = location.split("->").map { |name| params.find { |param| param.name == name } }
          "{ .start = #{from.start_location(params)}, .end = #{to.end_location(params)} }"
        else
          params.detect { |param| param.name == location }.location(params)
        end
      end
  end
end

class Token
  include Comparable

  attr_reader :name, :value, :comment

  def initialize(config)
    @name = config.fetch('name')
    @value = config['value']
    @comment = config.fetch('comment')
  end

  def declaration
    output = []
    output << "YP_TOKEN_#{name}"
    output << " = #{value}" if value
    output << ", // #{comment}"
    output.join(' ')
  end
end

ROOT_DIR = File.expand_path('..', __dir__)

def template(name, nodes, mark)
  filepath = File.expand_path(name, __dir__)
  contents = File.read(filepath).gsub(mark, ERB.new(File.read(File.expand_path("templates/#{File.basename(name)}.erb", __dir__)), trim_mode: "-").result_with_hash(nodes: nodes))
  File.write(filepath, contents)

  if ['.c', '.h'].include?(File.extname(filepath))
    system("clang-format -i #{filepath}")
  end
end

def pure_template(template:, write_to:, locals:)
  template = File.join(ROOT_DIR, template)
  write_to = File.join(ROOT_DIR, write_to)

  contents = ERB.new(File.read(template), trim_mode: "-").result_with_hash(locals)
  File.write(write_to, contents)

  if ['.c', '.h'].include?(File.extname(write_to))
    system("clang-format -i #{write_to}")
  end
end

cmark = %r{#{Regexp.escape(<<-CMARKBEGIN)}.+#{Regexp.escape(<<-CMARKEND)}}m
/******************************************************************************/
/* BEGIN TEMPLATE                                                             */
/******************************************************************************/
CMARKBEGIN
/******************************************************************************/
/* END TEMPLATE                                                               */
/******************************************************************************/
CMARKEND

rbmark = %r{#{Regexp.escape(<<-RBMARKBEGIN)}.+#{Regexp.escape(<<-RBMARKEND)}}m
  ##############################################################################
  # BEGIN TEMPLATE                                                             #
  ##############################################################################
RBMARKBEGIN
  ##############################################################################
  # END TEMPLATE                                                               #
  ##############################################################################
RBMARKEND

config = YAML.load_file(File.expand_path("../config.yml", __dir__))

nodes = config.fetch("nodes").map { |node| NodeType.new(node) }.sort_by(&:name)
tokens = config.fetch("tokens").map { |token| Token.new(token) }

template("../ext/yarp/extension.c", nodes, cmark)
template("../ext/yarp/yarp.c", nodes, cmark)
template("../lib/yarp.rb", nodes, rbmark)

pure_template(template: 'bin/templates/gen_token_type.h.erb', write_to: 'ext/yarp/gen_token_type.h', locals: { tokens: tokens })
pure_template(template: 'bin/templates/gen_token_type.c.erb', write_to: 'ext/yarp/gen_token_type.c', locals: { tokens: tokens })
pure_template(template: 'bin/templates/gen_node.h.erb', write_to: 'ext/yarp/gen_node.h', locals: { nodes: nodes })
